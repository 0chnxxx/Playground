<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.0/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1.6.1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <style>
        #messages, #all-rooms-list {
            scroll-behavior: smooth;
            display: flex;
            flex-direction: column;
        }
        #drawer {
            transition: transform 0.3s ease-in-out;
            transform: translateX(100%);
            display: none;
            position: absolute;
            right: 0;
            width: 66.666667%;
            height: 100%;
        }
        #drawer-overlay {
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            pointer-events: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        #drawer-overlay:not(.hidden) {
            opacity: 1;
            pointer-events: auto;
        }
        #app {
            position: relative;
        }
        #all-rooms-page {
            min-height: 100%;
        }
        #all-rooms-list {
            height: 100%;
            overflow-y: auto;
            flex: 1;
        }
        .room-image {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 9999px;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans flex items-center justify-center min-h-screen">
<div id="app" class="max-w-md w-full h-[75vh] bg-white shadow-lg flex flex-col overflow-hidden">
    <div id="login-page" class="flex-1 flex flex-col p-6 overflow-y-auto">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">로그인</h1>
        <div class="space-y-4">
            <input id="login-email" type="email" value="test@test.com" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <input id="login-password" type="password" value="12345678" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="login-btn" class="w-full p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">로그인</button>
            <button id="to-register-btn" class="w-full p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">회원가입</button>
        </div>
    </div>
    <div id="register-page" class="hidden flex-1 flex flex-col p-6 overflow-y-auto">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">회원가입</h1>
        <div class="space-y-4">
            <input id="register-email" type="email" placeholder="이메일" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <input id="register-nickname" type="text" placeholder="닉네임" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <input id="register-password" type="password" placeholder="비밀번호" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="register-btn" class="w-full p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">회원가입</button>
            <button id="back-to-login-btn" class="w-full p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">뒤로</button>
        </div>
    </div>
    <div id="rooms-page" class="hidden flex-1 flex flex-col h-full">
        <div class="p-6 bg-blue-500 text-white flex items-center justify-between shrink-0">
            <div class="flex items-center">
                <button id="logout-btn" class="mr-4 text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
                </button>
                <h1 class="text-xl font-bold">내 채팅방</h1>
            </div>
            <div class="flex space-x-2">
                <button id="search-rooms-btn" class="text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                </button>
                <button id="create-room-btn" class="text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>
                </button>
            </div>
        </div>
        <div id="rooms-list" class="flex-1 overflow-y-auto p-4 space-y-4"></div>
    </div>
    <div id="all-rooms-page" class="hidden flex-1 flex flex-col h-full">
        <div class="p-6 bg-blue-500 text-white flex items-center justify-between shrink-0">
            <div class="flex items-center">
                <button id="back-to-my-rooms-btn" class="mr-4 text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
                </button>
                <h1 class="text-xl font-bold">전체 채팅방</h1>
            </div>
        </div>
        <div id="all-rooms-list" class="p-4 space-y-4"></div>
    </div>
    <div id="chat-page" class="hidden flex-1 flex flex-col h-full relative">
        <div class="p-6 bg-blue-500 text-white flex items-center justify-between shrink-0">
            <div class="flex items-center">
                <button id="back-to-rooms-btn" class="mr-4 text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
                </button>
                <h1 id="chat-room-title" class="text-xl font-bold"></h1>
            </div>
            <button id="drawer-toggle-btn" class="text-white hover:text-gray-200">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" /></svg>
            </button>
        </div>
        <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-4 flex flex-col"></div>
        <div class="p-4 border-t shrink-0">
            <div class="flex space-x-2">
                <input id="message-input" type="text" placeholder="메시지 입력..." class="flex-1 p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="send-message-btn" class="p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">전송</button>
            </div>
        </div>
        <div id="drawer-overlay" class="hidden bg-black bg-opacity-50 z-10"></div>
        <div id="drawer" class="bg-white shadow-lg z-20 flex flex-col">
            <div class="p-6 bg-blue-500 text-white flex items-center justify-between shrink-0">
                <h2 class="text-lg font-bold">채팅방 유저</h2>
                <button id="drawer-close-btn" class="text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </div>
            <div id="room-users-list" class="flex-1 overflow-y-auto p-4 space-y-2"></div>
            <div class="p-4 border-t shrink-0">
                <button id="leave-room-btn" class="w-full p-3 bg-red-500 text-white rounded-lg hover:bg-red-600 transition">채팅방 나가기</button>
            </div>
        </div>
    </div>
    <div id="create-room-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-30">
        <div class="bg-white p-6 rounded-lg w-full max-w-sm">
            <h2 class="text-xl font-bold mb-4">새 채팅방 만들기</h2>
            <input id="room-name-input" type="text" placeholder="채팅방 이름" class="w-full p-3 border rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <div class="flex space-x-2">
                <button id="create-room-confirm-btn" class="flex-1 p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">만들기</button>
                <button id="create-room-cancel-btn" class="flex-1 p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">취소</button>
            </div>
        </div>
    </div>
    <div id="join-room-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-30">
        <div class="bg-white p-6 rounded-lg w-full max-w-sm">
            <h2 class="text-xl font-bold mb-4">채팅방에 참여하겠습니까?</h2>
            <div class="flex space-x-2">
                <button id="join-room-confirm-btn" class="flex-1 p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">예</button>
                <button id="join-room-cancel-btn" class="flex-1 p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">아니오</button>
            </div>
        </div>
    </div>
    <div id="leave-room-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-30">
        <div class="bg-white p-6 rounded-lg w-full max-w-sm">
            <h2 id="leave-room-title" class="text-xl font-bold mb-4"></h2>
            <div class="flex space-x-2">
                <button id="leave-room-confirm-btn" class="flex-1 p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">예</button>
                <button id="leave-room-cancel-btn" class="flex-1 p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">아니오</button>
            </div>
        </div>
    </div>
</div>

<script>
    let accessToken = localStorage.getItem('accessToken') || null;
    let refreshToken = localStorage.getItem('refreshToken') || null;
    let userId = localStorage.getItem('userId') || null;
    let nickname = localStorage.getItem('nickname') || null;
    let stompClient = null;
    let currentRoom = null;
    let currentRoomId = null;
    let currentPage = 1;
    let isLoadingRooms = false;
    let hasMoreRooms = true;
    let pendingRoom = null;
    let roomsCache = [];
    let allRoomsCache = [];
    let subscribedRooms = new Map();
    let messagePage = 1;
    let isLoadingMessages = false;
    let hasMoreMessages = true;
    let messagesCache = [];
    let processedMessageIds = new Set();
    let processedReadIds = new Set();
    let tempMessageMap = new Map();
    let isInitialRender = false;
    let roomUsersCache = [];
    let isLeavingRoom = false;
    let drawerTimeout = null;
    let scrollListener = null;
    
    // 메시지별 읽지 않은 사용자 추적을 위한 Map 추가
    let messageUnreadUsersMap = new Map(); // messageId -> Set of userIds

    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    function waitForWebSocketConnection(timeout = 5000) {
        return new Promise((resolve, reject) => {
            if (stompClient && stompClient.connected) {
                return resolve();
            }
            let elapsed = 0;
            const interval = 100;
            const check = setInterval(() => {
                elapsed += interval;
                if (stompClient && stompClient.connected) {
                    clearInterval(check);
                    resolve();
                } else if (elapsed >= timeout) {
                    clearInterval(check);
                    reject(new Error('WebSocket connection timeout'));
                }
            }, interval);
        });
    }

    async function ensureRoomSubscriptions(roomId, maxRetries = 3) {
        let attempts = 0;
        while (attempts < maxRetries) {
            try {
                await waitForWebSocketConnection(3000);
                if (!subscribedRooms.has(roomId)) {
                    subscribeToRoom(roomId);
                    subscribeToReadMessages(roomId);
                    return true;
                } else {
                    return true;
                }
            } catch (error) {
                attempts++;
                console.error(`Failed to subscribe to room ${roomId}, attempt ${attempts}:`, error);
                if (attempts >= maxRetries) {
                    console.error(`Max retries reached for room ${roomId}`);
                    return false;
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        return false;
    }

    async function sendViewMessage(roomId, messageId) {
        if (!stompClient) {
            console.warn('Cannot send view message: stompClient is null', { roomId, messageId });
            return;
        }
        
        if (!messageId) {
            console.warn('Cannot send view message: messageId is null or empty', { roomId, messageId });
            return;
        }
        
        const viewPayload = {
            userId,
            roomId,
            messageId,
            type: 'ALL'  // ALL 타입으로 전송하여 해당 메시지 이하의 모든 메시지를 읽음 처리
        };
        try {
            await waitForWebSocketConnection();
            stompClient.send(`/pub/chat/rooms/${roomId}/view`, {}, JSON.stringify(viewPayload));
            console.log('View message sent:', viewPayload);
        } catch (error) {
            console.warn('Failed to send view message:', error, viewPayload);
        }
    }

    async function sendReadMessage(roomId, messageId) {
        if (!stompClient || !stompClient.connected) {
            console.warn('Cannot send read message: WebSocket not connected', { roomId, messageId });
            return;
        }
        if (!messageId || processedReadIds.has(messageId)) {
            return;
        }
        const readPayload = {
            roomId: roomId,
            userId: userId,
            messageId: messageId,
            type: 'ONE'
        };
        try {
            await waitForWebSocketConnection();
            stompClient.send(`/pub/chat/rooms/${roomId}/messages/${messageId}/read`, {}, JSON.stringify(readPayload));
            processedReadIds.add(messageId);
        } catch (error) {
            console.warn('Failed to send read message:', error, readPayload);
        }
    }

    const pages = {
        'login': document.getElementById('login-page'),
        'register': document.getElementById('register-page'),
        'rooms': document.getElementById('rooms-page'),
        'all-rooms': document.getElementById('all-rooms-page'),
        'chat': document.getElementById('chat-page'),
    };

    function unsubscribeRoom(roomId) {
        const subscriptions = subscribedRooms.get(roomId);
        if (subscriptions) {
            try {
                if (subscriptions.send) subscriptions.send.unsubscribe();
                if (subscriptions.read) subscriptions.read.unsubscribe();
            } catch (error) {
                console.error(`Error unsubscribing room ${roomId}:`, error);
            }
            subscribedRooms.delete(roomId);
        }
    }

    function toggleDrawer() {
        const drawer = document.getElementById('drawer');
        const overlay = document.getElementById('drawer-overlay');
        const isOpening = drawer.style.display === 'none' || !drawer.style.display;

        if (isOpening) {
            if (drawerTimeout) {
                clearTimeout(drawerTimeout);
                drawerTimeout = null;
            }
            drawer.style.display = 'block';
            overlay.classList.remove('hidden');
            setTimeout(() => {
                drawer.style.transform = 'translateX(0)';
                overlay.style.opacity = '1';
            }, 10);
            fetchRoomUsers(currentRoomId);
        } else {
            drawer.style.transform = 'translateX(100%)';
            overlay.style.opacity = '0';
            drawerTimeout = setTimeout(() => {
                drawer.style.display = 'none';
                overlay.classList.add('hidden');
                drawerTimeout = null;
            }, 300);
        }
    }

    async function fetchRoomUsers(roomId) {
        try {
            const res = await api.get(`/chat/rooms/${roomId}/users`);
            roomUsersCache = res.data.data || [];
            renderRoomUsers();
            return roomUsersCache;
        } catch (error) {
            console.error('Failed to fetch room users:', error);
            alert('유저 목록을 불러오지 못했습니다.');
            roomUsersCache = [];
            renderRoomUsers();
            return [];
        }
    }

    function renderRoomUsers() {
        const usersList = document.getElementById('room-users-list');
        usersList.innerHTML = '';
        if (roomUsersCache.length === 0) {
            usersList.innerHTML = '<p class="text-gray-500 text-center">유저가 없습니다.</p>';
            return;
        }
        roomUsersCache.forEach(user => {
            const div = document.createElement('div');
            div.className = 'p-2 bg-gray-100 rounded-lg flex items-center space-x-2';
            div.innerHTML = `
                <span class="text-gray-800">${user.nickname}</span>
                ${user.isOwner ? '<svg class="w-4 h-4 text-yellow-500" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3 6h6l-3 6 3 6h-6l-3-6-3 6H3l3-6-3-6h6l3-6z" /></svg>' : ''}
            `;
            usersList.appendChild(div);
        });
    }

    async function leaveRoom(roomId) {
        const modal = document.getElementById('leave-room-modal');
        const title = document.getElementById('leave-room-title');
        const currentUser = roomUsersCache.find(user => user.id === userId);
        const isOwner = currentUser?.isOwner || false;

        title.textContent = isOwner ? '채팅방을 삭제하시겠습니까?' : '채팅방을 나가시겠습니까?';
        modal.classList.remove('hidden');
    }

    function confirmLeaveRoom(roomId) {
        isLeavingRoom = true;
        const currentUser = roomUsersCache.find(user => user.id === userId);
        const isOwner = currentUser?.isOwner || false;

        if (isOwner) {
            api.delete(`/chat/rooms/${roomId}`)
                .then(() => {
                    roomsCache = roomsCache.filter(room => room.id !== roomId);
                    allRoomsCache = allRoomsCache.filter(room => room.id !== roomId);
                    unsubscribeRoom(roomId);
                    alert('채팅방이 삭제되었습니다.');
                    toggleDrawer();
                    document.getElementById('leave-room-modal').classList.add('hidden');
                    navigate('rooms');
                    isLeavingRoom = false;
                })
                .catch(error => {
                    console.error('Failed to delete room:', error);
                    alert('채팅방 삭제에 실패했습니다: ' + error.response?.data?.message || '오류 발생');
                    isLeavingRoom = false;
                });
        } else {
            api.post(`/chat/rooms/${roomId}/leave`)
                .then(() => {
                    roomsCache = roomsCache.filter(room => room.id !== roomId);
                    allRoomsCache = allRoomsCache.map(room =>
                        room.id === roomId ? { ...room, isJoined: false, memberCount: Math.max(1, room.memberCount - 1) } : room
                    );
                    unsubscribeRoom(roomId);
                    alert('채팅방에서 나갔습니다.');
                    toggleDrawer();
                    document.getElementById('leave-room-modal').classList.add('hidden');
                    navigate('rooms');
                    isLeavingRoom = false;
                })
                .catch(error => {
                    console.error('Failed to leave room:', error);
                    alert('채팅방 나가기에 실패했습니다: ' + error.response?.data?.message || '오류 발생');
                    isLeavingRoom = false;
                });
        }
    }

    function setupInfiniteScroll() {
        const allRoomsList = document.getElementById('all-rooms-list');
        if (scrollListener) {
            allRoomsList.removeEventListener('scroll', scrollListener);
        }
        const debouncedLoadAllRooms = debounce(() => {
            const scrollPosition = allRoomsList.scrollTop + allRoomsList.clientHeight;
            const triggerPoint = allRoomsList.scrollHeight - 100;
            if (scrollPosition >= triggerPoint && !isLoadingRooms && hasMoreRooms) {
                loadRooms('all', true).then(() => {
                    currentPage++;
                });
            }
        }, 300);
        scrollListener = debouncedLoadAllRooms;
        setTimeout(() => {
            allRoomsList.addEventListener('scroll', scrollListener);
        }, 300);
    }

    function navigate(page, pushState = true) {
        Object.values(pages).forEach(p => p.classList.add('hidden'));
        pages[page].classList.remove('hidden');
        if (pushState) {
            history.pushState({ page }, '', `#${page}`);
        }
        if (page === 'rooms') {
            currentRoom = null;
            currentRoomId = null;
            document.getElementById('drawer').style.display = 'none';
            document.getElementById('drawer-overlay').classList.add('hidden');
            document.getElementById('leave-room-modal').classList.add('hidden');
            loadRooms('my');
        }
        if (page === 'all-rooms') {
            currentRoom = null;
            currentRoomId = null;
            document.getElementById('drawer').style.display = 'none';
            document.getElementById('drawer-overlay').classList.add('hidden');
            document.getElementById('leave-room-modal').classList.add('hidden');
            currentPage = 1;
            hasMoreRooms = true;
            allRoomsCache = [];
            const allRoomsList = document.getElementById('all-rooms-list');
            if (scrollListener) {
                allRoomsList.removeEventListener('scroll', scrollListener);
            }
            allRoomsList.scrollTop = 0;
            loadRooms('all', false).then(() => {
                allRoomsList.scrollTop = 0;
                setupInfiniteScroll();
            });
        }
        if (page === 'chat' && currentRoom) {
            currentRoomId = currentRoom.id;
            document.getElementById('chat-room-title').textContent = currentRoom.name;
            messagePage = 1;
            hasMoreMessages = true;
            messagesCache = [];
            processedMessageIds.clear();
            processedReadIds.clear();
            tempMessageMap.clear();
            roomUsersCache = [];
            messageUnreadUsersMap.clear(); // 읽지 않은 사용자 Map 초기화
            const messagesDiv = document.getElementById('messages');
            isInitialRender = true;
            
            // 먼저 채팅방 사용자 목록을 가져온 후 메시지를 로드
            fetchRoomUsers(currentRoom.id).then(() => {
                return loadMessages(currentRoom.id);
            }).then(() => {
                // 읽지 않은 모든 메시지에 대해 읽음 처리
                const unreadMessages = messagesCache.filter(msg => {
                    const unreadUsers = messageUnreadUsersMap.get(msg.id);
                    return unreadUsers && unreadUsers.has(String(userId));
                });
                
                if (unreadMessages.length > 0) {
                    // 가장 최근 읽지 않은 메시지로 ALL 타입 view 메시지 전송
                    const latestUnreadMessage = unreadMessages[unreadMessages.length - 1];
                    sendViewMessage(currentRoom.id, latestUnreadMessage.id);
                } else {
                    // 읽지 않은 메시지가 없다면 가장 최근 메시지로 처리
                    const latestMessage = messagesCache[messagesCache.length - 1];
                    const messageId = latestMessage && latestMessage.id && latestMessage.id !== '0' && latestMessage.id !== 0 ? latestMessage.id : null;
                    if (messageId) {
                        sendViewMessage(currentRoom.id, messageId);
                    }
                }
                
                ensureRoomSubscriptions(currentRoom.id);
                setTimeout(() => {
                    isInitialRender = false;
                }, 100);
                
                // DOM 렌더링 완료 후 스크롤을 최하단으로 이동
                setTimeout(() => {
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }, 50);
                
                // 추가적으로 더 확실하게 스크롤 처리
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    });
                });
            }).catch(error => {
                console.error('Error loading messages:', error);
                ensureRoomSubscriptions(currentRoom.id);
                isInitialRender = false;
            });
            
            // 추가적인 스크롤 보장 로직
            const ensureScrollToBottom = () => {
                const messagesDiv = document.getElementById('messages');
                if (messagesDiv) {
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }
            };
            
            // 다양한 시점에서 스크롤 처리
            setTimeout(ensureScrollToBottom, 200);
            setTimeout(ensureScrollToBottom, 500);
            setTimeout(ensureScrollToBottom, 1000);
        }
    }

    window.addEventListener('popstate', (e) => {
        const page = e.state?.page || 'login';
        navigate(page, false);
    });

    const api = axios.create({
        baseURL: 'http://localhost:8080',
        headers: { 'Content-Type': 'application/json' },
    });

    api.interceptors.request.use(config => {
        if (accessToken && config.url !== '/users/login' && config.url !== '/users/register' && config.url !== '/users/refresh') {
            config.headers.Authorization = `Bearer ${accessToken}`;
        }
        return config;
    });

    api.interceptors.response.use(
        response => response,
        async error => {
            const originalRequest = error.config;
            if (error.response?.status === 401 && !originalRequest._retry && originalRequest.url !== '/users/refresh') {
                originalRequest._retry = true;
                try {
                    const refreshResponse = await axios.post('http://localhost:8080/users/refresh', {}, {
                        headers: {
                            Authorization: `Bearer ${refreshToken}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    accessToken = refreshResponse.data.data.accessToken;
                    refreshToken = refreshResponse.data.data.refreshToken;
                    localStorage.setItem('accessToken', accessToken);
                    localStorage.setItem('refreshToken', refreshToken);
                    originalRequest.headers.Authorization = `Bearer ${accessToken}`;
                    return api(originalRequest);
                } catch (refreshError) {
                    if (refreshError.response?.status === 401) {
                        accessToken = null;
                        refreshToken = null;
                        userId = null;
                        nickname = null;
                        localStorage.removeItem('accessToken');
                        localStorage.removeItem('refreshToken');
                        localStorage.removeItem('userId');
                        localStorage.removeItem('nickname');
                        if (stompClient) {
                            stompClient.disconnect();
                            stompClient = null;
                        }
                        subscribedRooms.forEach((_, roomId) => unsubscribeRoom(roomId));
                        subscribedRooms.clear();
                        navigate('login');
                    }
                    return Promise.reject(refreshError);
                }
            }
            return Promise.reject(error);
        }
    );

    function connectWebSocket() {
        if (!accessToken) return;
        try {
            subscribedRooms.forEach((_, roomId) => unsubscribeRoom(roomId));
            subscribedRooms.clear();
            if (stompClient && stompClient.connected) {
                stompClient.disconnect();
            }
            const socket = new SockJS(`http://localhost:8081/ws?token=${accessToken}`);
            stompClient = Stomp.over(socket);
            stompClient.connect({}, () => {
                roomsCache.forEach(room => ensureRoomSubscriptions(room.id));
            }, (error) => {
                console.error('WebSocket connection error:', error);
                setTimeout(connectWebSocket, 5000);
            });
        } catch (error) {
            console.error('WebSocket connection failed:', error);
            setTimeout(connectWebSocket, 5000);
        }
    }

    function subscribeToRoom(roomId) {
        if (stompClient && stompClient.connected && !subscribedRooms.has(roomId)) {
            const subscription = stompClient.subscribe(`/sub/chat/rooms/${roomId}/messages/send`, (message) => {
                try {
                    const msg = JSON.parse(message.body);
                    const messageId = String(msg.messageId || msg.id || '');
                    if (!messageId) {
                        console.warn('Received message with missing or invalid messageId:', msg);
                        return;
                    }
                    if (processedMessageIds.has(messageId)) {
                        return;
                    }
                    processedMessageIds.add(messageId);
                    const room = roomsCache.find(r => r.id === roomId) || allRoomsCache.find(r => r.id === roomId);
                    const memberCount = room ? room.memberCount || 1 : 1;
                    const normalizedMsg = {
                        ...msg,
                        id: messageId,
                        roomId: roomId,
                        isMine: msg.userId == userId,
                        content: msg.content || msg.message || 'No content',
                        nickname: msg.nickname || 'Unknown',
                        timestamp: msg.timestamp ? new Date(msg.timestamp).toISOString() : new Date().toISOString(),
                        unreadCount: 0, // 초기값은 0으로 설정
                        isTemporary: false
                    };
                    
                    // 새 메시지의 경우 읽지 않은 사용자 목록 초기화
                    if (!messageUnreadUsersMap.has(messageId)) {
                        // 채팅방의 모든 사용자를 읽지 않은 사용자로 초기화
                        const unreadUsers = new Set();
                        
                        // roomUsersCache가 있으면 사용, 없으면 멤버 수 기반으로 초기화
                        if (roomUsersCache.length > 0) {
                            roomUsersCache.forEach(user => {
                                if (String(user.id) !== String(msg.userId)) {
                                    unreadUsers.add(String(user.id));
                                }
                            });
                        } else {
                            // 채팅방 멤버 수 기반으로 초기화 (자신 제외)
                            for (let i = 0; i < memberCount - 1; i++) {
                                unreadUsers.add(`unknown-${i}`);
                            }
                        }
                        
                        messageUnreadUsersMap.set(messageId, unreadUsers);
                        normalizedMsg.unreadCount = unreadUsers.size;
                    } else {
                        // 이미 있는 경우 현재 크기로 설정
                        const unreadUsers = messageUnreadUsersMap.get(messageId);
                        normalizedMsg.unreadCount = unreadUsers ? unreadUsers.size : 0;
                    }
                    if (!msg.content && !msg.message) {
                        console.warn('Message missing content:', msg);
                    }
                    if (currentRoomId === roomId && !pages['chat'].classList.contains('hidden')) {
                        let tempMsg = null;
                        let tempId = null;
                        for (let [key, value] of tempMessageMap.entries()) {
                            const cached = messagesCache.find(m => m.id === key);
                            if (cached && cached.content === normalizedMsg.content && cached.userId === normalizedMsg.userId && cached.isTemporary) {
                                tempMsg = cached;
                                tempId = key;
                                break;
                            }
                        }
                        if (tempMsg && tempId) {
                            // 읽지 않은 사용자 수 계산
                            const unreadUsers = messageUnreadUsersMap.get(messageId) || new Set();
                            const unreadCount = normalizedMsg.isMine ? unreadUsers.size : unreadUsers.size;
                            
                            messagesCache = messagesCache.map(m =>
                                m.id === tempId
                                    ? { ...normalizedMsg, id: messageId, isTemporary: false, unreadCount: unreadCount }
                                    : m
                            );
                            const messageElement = document.querySelector(`[data-message-id="${tempId}"]`);
                            if (messageElement) {
                                messageElement.setAttribute('data-message-id', messageId);
                                updateUnreadSpan(messageElement, messageId, unreadCount);
                                const contentElement = messageElement.querySelector('p.text-sm');
                                if (contentElement) contentElement.textContent = normalizedMsg.content;
                                const timestampElement = messageElement.querySelector('.timestamp');
                                if (timestampElement) timestampElement.textContent = new Date(normalizedMsg.timestamp).toLocaleTimeString();
                            }
                            tempMessageMap.delete(tempId);
                        } else {
                            const recentDuplicate = messagesCache.find(cached =>
                                cached.content === normalizedMsg.content &&
                                cached.userId === normalizedMsg.userId &&
                                Math.abs(new Date().getTime() - new Date(cached.timestamp).getTime()) < 1000 &&
                                !cached.isTemporary
                            );
                            if (!recentDuplicate && !messagesCache.some(cached => cached.id === normalizedMsg.id)) {
                                messagesCache.push(normalizedMsg);
                                appendMessage(normalizedMsg, true); // 스크롤 활성화
                            }
                        }
                        if (!processedReadIds.has(normalizedMsg.id)) {
                            // 현재 채팅방에 있을 때만 자동으로 읽음 처리
                            sendReadMessage(roomId, normalizedMsg.id);
                        }
                    } else {
                        messagesCache.push(normalizedMsg);
                    }
                    updateRoomLastMessage(roomId, normalizedMsg);
                } catch (error) {
                    console.error('Error processing WebSocket message:', error, message.body);
                }
            });
            subscribedRooms.set(roomId, {
                send: subscription,
                read: subscribedRooms.get(roomId)?.read
            });
        }
    }

    function updateUnreadSpan(messageElement, messageId, unreadCount) {
        if (!messageElement) {
            console.warn('Cannot update unread span: messageElement is null', { messageId, unreadCount });
            return;
        }
        let infoBlock = messageElement.querySelector('.flex.flex-col');
        if (!infoBlock) {
            console.warn('infoBlock not found, creating new one', { messageId });
            const messageContent = messageElement.querySelector('.flex.items-end') || messageElement.querySelector('.flex.items-end.flex-row-reverse');
            if (messageContent) {
                infoBlock = document.createElement('div');
                infoBlock.className = `flex flex-col ${messageElement.classList.contains('justify-end') ? 'items-end ml-1' : 'items-start mr-1'} text-gray-500 text-xs leading-tight`;
                messageContent.appendChild(infoBlock);
            } else {
                console.error('Cannot create infoBlock: no suitable parent found', { messageId, elementHTML: messageElement.outerHTML });
                return;
            }
        }
        let unreadSpan = infoBlock.querySelector('.unread-count');
        if (unreadCount > 0) {
            if (!unreadSpan) {
                unreadSpan = document.createElement('span');
                unreadSpan.className = 'unread-count text-gray-500 text-xs';
                const timestampSpan = infoBlock.querySelector('.timestamp');
                if (timestampSpan) {
                    infoBlock.insertBefore(unreadSpan, timestampSpan);
                } else {
                    infoBlock.appendChild(unreadSpan);
                }
            }
            unreadSpan.textContent = unreadCount;
        } else if (unreadSpan) {
            unreadSpan.remove();
        }
    }

    function subscribeToReadMessages(roomId) {
        if (stompClient && stompClient.connected && !subscribedRooms.get(roomId)?.read) {
            const subscription = stompClient.subscribe(`/sub/chat/rooms/${roomId}/messages/read`, (message) => {
                try {
                    const readMsg = JSON.parse(message.body);
                    if (!readMsg.messageId) {
                        console.warn('Read message missing messageId:', readMsg);
                        return;
                    }
                    if (!readMsg.userId) {
                        console.warn('Read message missing userId:', readMsg);
                        return;
                    }
                    if (!readMsg.type || !['ALL', 'ONE'].includes(readMsg.type)) {
                        console.warn('Read message missing or invalid type:', readMsg);
                        return;
                    }

                    const readUserId = String(readMsg.userId);
                    const roomIndex = roomsCache.findIndex(room => room.id === roomId);
                    if (roomIndex === -1) {
                        console.warn(`Room ${roomId} not found in roomsCache`);
                        return;
                    }

                    if (currentRoomId === roomId) {
                        let messagesToUpdate = [];

                        if (readMsg.type === 'ALL') {
                            // ALL 타입의 경우 messageId 이하의 모든 메시지에서 해당 사용자 제거
                            const targetMessageId = String(readMsg.messageId);
                            messagesCache.forEach(msg => {
                                if (msg.roomId === roomId) {
                                    // 메시지 ID를 숫자로 비교하거나 타임스탬프로 비교
                                    const shouldUpdate = parseInt(msg.id) <= parseInt(targetMessageId) || 
                                                       new Date(msg.timestamp) <= new Date(messagesCache.find(m => String(m.id) === targetMessageId)?.timestamp || new Date());
                                    
                                    if (shouldUpdate) {
                                        const unreadUsers = messageUnreadUsersMap.get(msg.id);
                                        if (unreadUsers && unreadUsers.has(readUserId)) {
                                            unreadUsers.delete(readUserId);
                                            messagesToUpdate.push(msg);
                                        }
                                    }
                                }
                            });
                        } else if (readMsg.type === 'ONE') {
                            // ONE 타입의 경우 특정 메시지에서만 해당 사용자 제거
                            const unreadUsers = messageUnreadUsersMap.get(String(readMsg.messageId));
                            if (unreadUsers && unreadUsers.has(readUserId)) {
                                unreadUsers.delete(readUserId);
                                const msg = messagesCache.find(m => String(m.id) === String(readMsg.messageId));
                                if (msg) {
                                    messagesToUpdate.push(msg);
                                }
                            }
                        }

                        // 메시지 캐시 업데이트
                        messagesCache = messagesCache.map(msg => {
                            const isTarget = messagesToUpdate.some(target => target.id === msg.id);
                            if (isTarget) {
                                const unreadUsers = messageUnreadUsersMap.get(msg.id);
                                const newUnreadCount = unreadUsers ? unreadUsers.size : 0;
                                return { ...msg, unreadCount: newUnreadCount };
                            }
                            return msg;
                        });

                        // DOM 업데이트
                        if (!pages['chat'].classList.contains('hidden')) {
                            const messagesDiv = document.getElementById('messages');
                            messagesToUpdate.forEach(msg => {
                                const unreadUsers = messageUnreadUsersMap.get(msg.id);
                                const newUnreadCount = unreadUsers ? unreadUsers.size : 0;
                                const messageElement = messagesDiv.querySelector(`[data-message-id="${msg.id}"]`);
                                if (messageElement) {
                                    updateUnreadSpan(messageElement, msg.id, newUnreadCount);
                                }
                            });
                        }
                    } else {
                        // 다른 방에서의 읽음 처리
                        const targetRoom = roomsCache[roomIndex];
                        if (targetRoom && targetRoom.unreadCount > 0 && readUserId === String(userId)) {
                            roomsCache[roomIndex] = {
                                ...targetRoom,
                                unreadCount: Math.max(0, targetRoom.unreadCount - 1)
                            };
                            renderRooms('my');
                        }
                    }
                } catch (error) {
                    console.error('Error processing read message:', error, message.body);
                }
            });
            subscribedRooms.set(roomId, {
                send: subscribedRooms.get(roomId)?.send,
                read: subscription
            });
        }
    }

    function updateRoomLastMessage(roomId, msg) {
        const roomIndex = roomsCache.findIndex(room => room.id === roomId);
        if (roomIndex !== -1) {
            roomsCache[roomIndex].lastMessage = msg.content || msg.message;
            roomsCache[roomIndex].lastMessageTime = msg.timestamp;
            if (msg.userId !== userId && currentRoomId !== roomId) {
                roomsCache[roomIndex].unreadCount = (roomsCache[roomIndex].unreadCount || 0) + 1;
            } else {
                roomsCache[roomIndex].unreadCount = 0;
            }
            roomsCache.sort((a, b) => new Date(b.lastMessageTime || 0) - new Date(a.lastMessageTime || 0));
            renderRooms('my');
        } else {
            console.warn(`Room ${roomId} not found in roomsCache, fetching room`);
            api.get(`/chat/rooms/${roomId}`).then(res => {
                const room = res.data.data;
                roomsCache.push({
                    ...room,
                    lastMessage: msg.content || msg.message,
                    lastMessageTime: msg.timestamp,
                    unreadCount: msg.userId === userId ? 0 : 1,
                    memberCount: room.memberCount || 1
                });
                roomsCache.sort((a, b) => new Date(b.lastMessageTime || 0) - new Date(a.lastMessageTime || 0));
                renderRooms('my');
            }).catch(error => {
                console.error('Failed to fetch room:', error);
            });
        }
        const allRoomIndex = allRoomsCache.findIndex(room => room.id === roomId);
        if (allRoomIndex !== -1) {
            allRoomsCache[allRoomIndex].lastMessage = msg.content || msg.message;
            allRoomsCache[allRoomIndex].lastMessageTime = msg.timestamp;
            renderRooms('all');
        }
    }

    function renderRooms(type) {
        const roomsList = type === 'my' ? document.getElementById('rooms-list') : document.getElementById('all-rooms-list');
        const cache = type === 'my' ? roomsCache : allRoomsCache;
        if (cache.length === 0) {
            roomsList.innerHTML = '<p class="text-gray-500 text-center">No rooms available</p>';
            return;
        }
        const fragment = document.createDocumentFragment();
        cache.forEach(room => {
            const div = document.createElement('div');
            div.className = 'p-4 bg-gray-100 rounded-lg hover:bg-gray-200 cursor-pointer';
            const imageSrc = room.image || 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22%23e5e7eb%22%3E%3Ccircle cx=%2212%22 cy=%2212%22 r=%2212%22/%3E%3C/svg%3E';
            div.innerHTML = `
                <div class="flex items-center space-x-3">
                    <img src="${imageSrc}" class="room-image" alt="Room image">
                    <div class="flex-1">
                        <div class="flex justify-between">
                            <h2 class="font-bold">${room.name || 'Unnamed Room'} <span class="text-gray-500 text-sm">(${room.memberCount || 0})</span></h2>
                            <span class="text-sm text-gray-500">${room.lastMessageTime ? new Date(room.lastMessageTime).toLocaleTimeString() : ''}</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <p class="text-gray-600 truncate flex-1">${room.lastMessage || 'No messages'}</p>
                            ${room.unreadCount > 0 ? `<div class="bg-red-500 text-white text-xs px-2 py-1 rounded-full">${room.unreadCount}</div>` : ''}
                        </div>
                    </div>
                </div>
            `;
            div.addEventListener('click', () => {
                currentRoom = room;
                if (type === 'all' && !room.isJoined) {
                    pendingRoom = room;
                    document.getElementById('join-room-modal').classList.remove('hidden');
                } else {
                    room.unreadCount = 0;
                    renderRooms(type);
                    navigate('chat');
                }
            });
            fragment.appendChild(div);
        });
        roomsList.innerHTML = '';
        roomsList.appendChild(fragment);
    }

    async function register(email, nickname, password) {
        try {
            const res = await api.post('/users/register', { email, nickname, password });
            accessToken = res.data.data.accessToken;
            refreshToken = res.data.data.refreshToken;
            localStorage.setItem('accessToken', accessToken);
            localStorage.setItem('refreshToken', refreshToken);
            alert('회원가입 성공! 로그인해주세요.');
            navigate('login');
        } catch (error) {
            alert('회원가입 실패: ' + error.response?.data?.message || '오류 발생');
        }
    }

    async function login(email, password) {
        try {
            const res = await api.post('/users/login', { email, password });
            accessToken = res.data.data.accessToken;
            refreshToken = res.data.data.refreshToken;
            localStorage.setItem('accessToken', accessToken);
            localStorage.setItem('refreshToken', refreshToken);
            await fetchCurrentUser();
            connectWebSocket();
            navigate('rooms');
        } catch (error) {
            alert('로그인 실패: ' + error.response?.data?.message || '오류 발생');
        }
    }

    async function fetchCurrentUser() {
        try {
            const res = await api.get('/users/me');
            userId = res.data.data.id;
            nickname = res.data.data.nickname;
            localStorage.setItem('userId', userId);
            localStorage.setItem('nickname', nickname);
        } catch (error) {
            console.error('Failed to fetch user:', error);
            throw error;
        }
    }

    async function createRoom(name) {
        try {
            const res = await api.post('/chat/rooms', { name });
            const newRoom = res.data.data;
            currentRoom = newRoom;
            currentRoomId = newRoom.id;
            roomsCache.unshift(newRoom);
            renderRooms('my');
            const subscribed = await ensureRoomSubscriptions(newRoom.id);
            if (!subscribed) {
                throw new Error('Failed to subscribe to room after creation');
            }
            alert('채팅방이 생성되었습니다.');
            document.getElementById('create-room-modal').classList.add('hidden');
            document.getElementById('room-name-input').value = '';
            navigate('chat');
        } catch (error) {
            console.error('Error creating room:', error);
            alert('채팅방 생성 실패: ' + error.message || error.response?.data?.message || '오류 발생');
            if (error.message.includes('subscribe')) {
                connectWebSocket();
            }
        }
    }

    async function joinRoom(roomId) {
        try {
            await api.post(`/chat/rooms/${roomId}/join`);
            const room = allRoomsCache.find(r => r.id === roomId);
            if (room) {
                room.isJoined = true;
                room.memberCount = room.memberCount ? room.memberCount + 1 : 1;
                roomsCache.unshift(room);
                currentRoom = room;
                currentRoomId = roomId;
                renderRooms('my');
            }
            await ensureRoomSubscriptions(roomId);
            navigate('chat');
        } catch (error) {
            alert('채팅방 참여 실패: ' + error.response?.data?.message || '오류 발생');
        }
    }

    async function loadRooms(type, append = false) {
        if (isLoadingRooms) {
            return;
        }
        if (type === 'all' && append && allRoomsCache.length >= currentPage * 10) {
            isLoadingRooms = false;
            return;
        }
        isLoadingRooms = true;
        try {
            const endpoint = type === 'all' ? `/chat/rooms?page=${currentPage}&size=10` : '/chat/rooms/me';
            const res = await api.get(endpoint);
            const roomsList = type === 'my' ? document.getElementById('rooms-list') : document.getElementById('all-rooms-list');
            const cache = type === 'my' ? roomsCache : allRoomsCache;
            if (!append) {
                cache.length = 0;
                roomsList.innerHTML = '';
            }
            const rooms = (res.data.data || []).map(room => ({
                ...room,
                lastMessageTime: room.lastSentAt ? new Date(room.lastSentAt).toISOString() : null,
                unreadCount: room.unreadCount || 0,
                memberCount: room.memberCount || 1
            }));
            if (type === 'my') {
                cache.push(...rooms);
                cache.sort((a, b) => new Date(b.lastMessageTime || 0) - new Date(a.lastMessageTime || 0));
                if (stompClient && stompClient.connected) {
                    rooms.forEach(room => {
                        ensureRoomSubscriptions(room.id);
                    });
                }
            } else {
                const existingIds = new Set(cache.map(room => room.id));
                const newRooms = rooms.filter(room => !existingIds.has(room.id));
                cache.push(...newRooms);
                if (rooms.length < 10) {
                    hasMoreRooms = false;
                }
            }
            renderRooms(type);
        } catch (error) {
            console.error('Failed to load rooms:', error);
            alert('채팅방 목록을 불러오지 못했습니다.');
        } finally {
            isLoadingRooms = false;
        }
    }

    async function loadMessages(roomId, append = false) {
        if (isLoadingMessages || !hasMoreMessages) return;
        isLoadingMessages = true;
        try {
            const res = await api.get(`/chat/rooms/${roomId}/messages?page=${messagePage}&size=30`);
            const messagesDiv = document.getElementById('messages');
            const scrollHeightBefore = messagesDiv.scrollHeight;
            const scrollTopBefore = messagesDiv.scrollTop;
            const wasAtBottom = messagesDiv.scrollTop + messagesDiv.clientHeight >= messagesDiv.scrollHeight - 50;

            if (!append) {
                messagesCache = [];
                processedMessageIds.clear();
                messagesDiv.innerHTML = '';
            }

            const messages = Array.isArray(res.data.data) ? res.data.data.map(msg => {
                const id = String(msg.messageId || msg.id || '');
                if (!id) {
                    console.warn('Message missing id:', msg);
                }
                
                // 읽지 않은 사용자 목록 초기화 (서버에서 온 데이터 우선)
                if (msg.unreadUserIds !== undefined && Array.isArray(msg.unreadUserIds)) {
                    messageUnreadUsersMap.set(id, new Set(msg.unreadUserIds.map(uid => String(uid))));
                } else if (!messageUnreadUsersMap.has(id)) {
                    // 서버에서 unreadUserIds가 없다면 빈 Set으로 초기화 (이미 모두 읽음)
                    messageUnreadUsersMap.set(id, new Set());
                }
                
                const unreadUsers = messageUnreadUsersMap.get(id) || new Set();
                
                return {
                    ...msg,
                    id,
                    roomId,
                    isMine: msg.userId == userId,
                    content: msg.content || 'No content',
                    nickname: msg.nickname || 'Unknown',
                    timestamp: msg.timestamp || new Date().toISOString(),
                    unreadCount: unreadUsers.size,
                    isTemporary: false
                };
            }).filter(msg => msg.id) : [];
            if (messages.length < 30) {
                hasMoreMessages = false;
            }

            messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (append) {
                messagesCache.unshift(...messages);
            } else {
                messagesCache.push(...messages);
            }

            renderMessages(messagesDiv, wasAtBottom, scrollHeightBefore, append, scrollTopBefore, messages);

            if (!append) {
                // 초기 로딩시 확실한 스크롤 처리
                const forceScrollToBottom = () => {
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                };
                
                // 여러 시점에서 스크롤 시도
                setTimeout(forceScrollToBottom, 0);
                setTimeout(forceScrollToBottom, 100);
                
                requestAnimationFrame(() => {
                    forceScrollToBottom();
                    requestAnimationFrame(forceScrollToBottom);
                });
            } else {
                messagesDiv.scrollTop = messagesDiv.scrollHeight - scrollHeightBefore + scrollTopBefore;
            }

            messagePage++;
        } catch (error) {
            console.error('Failed to load messages:', error);
            alert('메시지를 불러오지 못했습니다.');
            throw error;
        } finally {
            isLoadingMessages = false;
        }
    }

    function renderMessages(messagesDiv, wasAtBottom, scrollHeightBefore, append, scrollTopBefore, messages = []) {
        if (!append) {
            messagesDiv.innerHTML = '';
        }
        if (messagesCache.length === 0) {
            messagesDiv.innerHTML = '<p class="text-gray-500 text-center">No messages</p>';
            return;
        }
        const messagesToRender = append ? messages : messagesCache;
        messagesToRender.forEach(msg => {
            appendMessage(msg, false, append);
        });
        
        // 초기 로딩시 스크롤을 최하단으로 확실히 이동
        if (!append) {
            // 여러 번 시도하여 확실한 스크롤 처리
            const scrollToBottom = () => {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            };
            
            // 즉시 실행
            scrollToBottom();
            
            // DOM 업데이트 후 실행
            setTimeout(scrollToBottom, 0);
            setTimeout(scrollToBottom, 50);
            
            // requestAnimationFrame으로 추가 보장
            requestAnimationFrame(() => {
                scrollToBottom();
                requestAnimationFrame(scrollToBottom);
            });
        }
    }

    function appendMessage(msg, scrollToBottom = true, prepend = false) {
        const messagesDiv = document.getElementById('messages');
        if (!msg.id) {
            console.warn('Skipping message with missing id:', msg);
            return;
        }

        const tempId = [...tempMessageMap.keys()].find(key => tempMessageMap.get(key) === msg.id || key === msg.id);
        const existingElement = messagesDiv.querySelector(`[data-message-id="${msg.id}"]`) ||
            (tempId ? messagesDiv.querySelector(`[data-message-id="${tempId}"]`) : null);

        if (existingElement) {
            existingElement.setAttribute('data-message-id', msg.id);
            const contentElement = existingElement.querySelector('p.text-sm');
            if (contentElement) contentElement.textContent = msg.content;
            const timestampElement = existingElement.querySelector('.timestamp');
            if (timestampElement) timestampElement.textContent = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : '';
            updateUnreadSpan(existingElement, msg.id, msg.unreadCount);
            return;
        }

        const div = document.createElement('div');
        div.setAttribute('data-message-id', msg.id);
        const isMine = msg.isMine || false;
        const nickname = msg.nickname || 'Unknown';
        const content = msg.content || 'No content';
        const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : '';
        const unread = msg.unreadCount > 0 ? `<span class="unread-count text-gray-500 text-xs">${msg.unreadCount}</span>` : '';

        const infoBlock = `
            <div class="flex flex-col ${isMine ? 'items-end ml-1' : 'items-start mr-1'} text-gray-500 text-xs leading-tight">
                ${unread}
                ${timestamp ? `<span class="timestamp ${isMine ? 'mt-1' : ''} text-gray-500 text-xs">${timestamp}</span>` : ''}
            </div>
        `;

        div.className = `flex items-start mb-2 ${isMine ? 'justify-end' : 'justify-start'}`;
        div.innerHTML = `
            <div class="flex flex-col max-w-xs">
                <p class="text-xs text-gray-600 mb-1 ${isMine ? 'text-right' : 'text-left'}">${nickname}</p>
                <div class="flex items-end ${isMine ? 'flex-row-reverse' : 'flex-row'}">
                    <div class="p-3 rounded-lg ${isMine ? 'bg-blue-500 text-white ml-1' : 'bg-gray-200 text-gray-800 mr-1'}">
                        <p class="text-sm">${content}</p>
                    </div>
                    ${infoBlock}
                </div>
            </div>
        `;

        try {
            // 스크롤 위치 체크: 사용자가 하단 근처에 있는지 확인
            const wasAtBottom = messagesDiv.scrollTop + messagesDiv.clientHeight >= messagesDiv.scrollHeight - 100;
            
            if (prepend) {
                messagesDiv.insertBefore(div, messagesDiv.firstChild);
            } else {
                messagesDiv.appendChild(div);
            }
            
            // 스크롤 처리 로직 개선
            if (!prepend && scrollToBottom) {
                // 내 메시지이거나 사용자가 하단 근처에 있으면 자동 스크롤
                if (isMine || wasAtBottom) {
                    // 부드러운 스크롤을 위해 requestAnimationFrame 사용
                    requestAnimationFrame(() => {
                        messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    });
                }
            }
        } catch (error) {
            console.error('Error appending message to DOM:', error, msg, div.outerHTML);
        }
    }

    async function sendMessage() {
        const content = document.getElementById('message-input').value;
        if (!content.trim()) {
            alert('메시지를 입력하세요.');
            return;
        }
        if (!stompClient || !stompClient.connected) {
            alert('WebSocket 연결이 없습니다. 다시 시도해주세요.');
            return;
        }
        if (!currentRoom) {
            alert('채팅방이 선택되지 않았습니다.');
            return;
        }
        try {
            if (!subscribedRooms.has(currentRoom.id)) {
                const subscribed = await ensureRoomSubscriptions(currentRoom.id);
                if (!subscribed) {
                    throw new Error('Failed to subscribe to room before sending message');
                }
            }
            const tempId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            // 채팅방 사용자 수 계산 (자신 제외)
            const unreadUsersCount = roomUsersCache.length > 0 ? roomUsersCache.length - 1 : currentRoom.memberCount - 1;
            
            const tempMessage = {
                id: tempId,
                roomId: currentRoom.id,
                userId: userId,
                nickname: nickname,
                content: content,
                isMine: true,
                timestamp: new Date().toISOString(),
                unreadCount: unreadUsersCount,
                isTemporary: true
            };
            messagesCache.push(tempMessage);
            tempMessageMap.set(tempId, tempId);
            appendMessage(tempMessage, true); // 내 메시지는 항상 스크롤
            stompClient.send(`/pub/chat/rooms/${currentRoom.id}/messages/send`, {}, JSON.stringify({
                roomId: currentRoom.id,
                userId: userId,
                nickname: nickname,
                content: content
            }));
            document.getElementById('message-input').value = '';
        } catch (error) {
            console.error('Error sending message:', error);
            alert('메시지 전송에 실패했습니다: ' + error.message);
        }
    }

    document.getElementById('login-btn').addEventListener('click', () => {
        const email = document.getElementById('login-email').value;
        const password = document.getElementById('login-password').value;
        login(email, password);
    });

    document.getElementById('to-register-btn').addEventListener('click', () => navigate('register'));

    document.getElementById('register-btn').addEventListener('click', () => {
        const email = document.getElementById('register-email').value;
        const nickname = document.getElementById('register-nickname').value;
        const password = document.getElementById('register-password').value;
        register(email, nickname, password);
    });

    document.getElementById('back-to-login-btn').addEventListener('click', () => navigate('login'));

    document.getElementById('logout-btn').addEventListener('click', () => {
        accessToken = null;
        refreshToken = null;
        userId = null;
        nickname = null;
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('userId');
        localStorage.removeItem('nickname');
        if (stompClient) {
            stompClient.disconnect();
            stompClient = null;
        }
        subscribedRooms.forEach((_, roomId) => unsubscribeRoom(roomId));
        subscribedRooms.clear();
        navigate('login');
    });

    document.getElementById('search-rooms-btn').addEventListener('click', () => navigate('all-rooms'));

    document.getElementById('create-room-btn').addEventListener('click', () => {
        document.getElementById('create-room-modal').classList.remove('hidden');
    });

    document.getElementById('create-room-confirm-btn').addEventListener('click', () => {
        const name = document.getElementById('room-name-input').value;
        if (name.trim()) {
            createRoom(name);
        } else {
            alert('채팅방 이름을 입력하세요.');
        }
    });

    document.getElementById('create-room-cancel-btn').addEventListener('click', () => {
        document.getElementById('create-room-modal').classList.add('hidden');
        document.getElementById('room-name-input').value = '';
    });

    document.getElementById('back-to-my-rooms-btn').addEventListener('click', () => navigate('rooms'));

    document.getElementById('join-room-confirm-btn').addEventListener('click', () => {
        if (pendingRoom) {
            joinRoom(pendingRoom.id);
            document.getElementById('join-room-modal').classList.add('hidden');
            pendingRoom = null;
        }
    });

    document.getElementById('join-room-cancel-btn').addEventListener('click', () => {
        document.getElementById('join-room-modal').classList.add('hidden');
        pendingRoom = null;
    });

    document.getElementById('back-to-rooms-btn').addEventListener('click', () => navigate('rooms'));

    document.getElementById('send-message-btn').addEventListener('click', sendMessage);

    document.getElementById('message-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    document.getElementById('drawer-toggle-btn').addEventListener('click', toggleDrawer);

    document.getElementById('drawer-close-btn').addEventListener('click', toggleDrawer);

    document.getElementById('drawer-overlay').addEventListener('click', toggleDrawer);

    document.getElementById('leave-room-btn').addEventListener('click', () => {
        if (currentRoomId) {
            leaveRoom(currentRoomId);
        }
    });

    document.getElementById('leave-room-confirm-btn').addEventListener('click', () => {
        if (currentRoomId) {
            confirmLeaveRoom(currentRoomId);
        }
    });

    document.getElementById('leave-room-cancel-btn').addEventListener('click', () => {
        document.getElementById('leave-room-modal').classList.add('hidden');
    });

    document.getElementById('messages').addEventListener('scroll', () => {
        const messagesDiv = document.getElementById('messages');
        if (messagesDiv.scrollTop < 100 && !isLoadingMessages && hasMoreMessages) {
            loadMessages(currentRoomId, true);
        }
    });

    if (accessToken && refreshToken) {
        fetchCurrentUser().then(() => {
            connectWebSocket();
            navigate('rooms');
        }).catch(() => {
            navigate('login');
        });
    } else {
        navigate('login');
    }
</script>
</body>
</html>
