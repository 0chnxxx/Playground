<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.0/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1.6.1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <style>
        #messages {
            scroll-behavior: smooth;
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans flex items-center justify-center min-h-screen">
<div id="app" class="max-w-md w-full h-[75vh] bg-white shadow-lg flex flex-col overflow-hidden">
    <div id="login-page" class="flex-1 flex flex-col p-6 overflow-y-auto">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">로그인</h1>
        <div class="space-y-4">
            <input id="login-email" type="email" value="test@test.com" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <input id="login-password" type="password" value="12345678" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="login-btn" class="w-full p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">로그인</button>
            <button id="to-register-btn" class="w-full p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">회원가입</button>
        </div>
    </div>
    <div id="register-page" class="hidden flex-1 flex flex-col p-6 overflow-y-auto">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">회원가입</h1>
        <div class="space-y-4">
            <input id="register-email" type="email" placeholder="이메일" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <input id="register-nickname" type="text" placeholder="닉네임" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <input id="register-password" type="password" placeholder="비밀번호" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="register-btn" class="w-full p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">회원가입</button>
            <button id="back-to-login-btn" class="w-full p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">뒤로</button>
        </div>
    </div>
    <div id="rooms-page" class="hidden flex-1 flex flex-col h-full">
        <div class="p-6 bg-blue-500 text-white flex items-center justify-between shrink-0">
            <div class="flex items-center">
                <button id="logout-btn" class="mr-4 text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
                </button>
                <h1 class="text-xl font-bold">내 채팅방</h1>
            </div>
            <div class="flex space-x-2">
                <button id="search-rooms-btn" class="text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                </button>
                <button id="create-room-btn" class="text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>
                </button>
            </div>
        </div>
        <div id="rooms-list" class="flex-1 overflow-y-auto p-4 space-y-4"></div>
    </div>
    <div id="all-rooms-page" class="hidden flex-1 flex flex-col h-full">
        <div class="p-6 bg-blue-500 text-white flex items-center justify-between shrink-0">
            <div class="flex items-center">
                <button id="back-to-my-rooms-btn" class="mr-4 text-white hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
                </button>
                <h1 class="text-xl font-bold">전체 채팅방</h1>
            </div>
        </div>
        <div id="all-rooms-list" class="flex-1 overflow-y-auto p-4 space-y-4"></div>
    </div>
    <div id="chat-page" class="hidden flex-1 flex flex-col h-full">
        <div class="p-6 bg-blue-500 text-white flex items-center shrink-0">
            <button id="back-to-rooms-btn" class="mr-4 text-white hover:text-gray-200">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
            </button>
            <h1 id="chat-room-title" class="text-xl font-bold"></h1>
        </div>
        <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-4 flex flex-col"></div>
        <div class="p-4 border-t shrink-0">
            <div class="flex space-x-2">
                <input id="message-input" type="text" placeholder="메시지 입력..." class="flex-1 p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="send-message-btn" class="p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">전송</button>
            </div>
        </div>
    </div>
    <div id="create-room-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg w-full max-w-sm">
            <h2 class="text-xl font-bold mb-4">새 채팅방 만들기</h2>
            <input id="room-name-input" type="text" placeholder="채팅방 이름" class="w-full p-3 border rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <div class="flex space-x-2">
                <button id="create-room-confirm-btn" class="flex-1 p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">만들기</button>
                <button id="create-room-cancel-btn" class="flex-1 p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">취소</button>
            </div>
        </div>
    </div>
    <div id="join-room-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg w-full max-w-sm">
            <h2 class="text-xl font-bold mb-4">채팅방에 참여하겠습니까?</h2>
            <div class="flex space-x-2">
                <button id="join-room-confirm-btn" class="flex-1 p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">예</button>
                <button id="join-room-cancel-btn" class="flex-1 p-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">아니오</button>
            </div>
        </div>
    </div>
</div>

<script>
    let accessToken = localStorage.getItem('accessToken') || null;
    let refreshToken = localStorage.getItem('refreshToken') || null;
    let userId = localStorage.getItem('userId') || null;
    let nickname = localStorage.getItem('nickname') || null;
    let stompClient = null;
    let currentRoom = null;
    let currentRoomId = null;
    let currentRoomMemberCount = 0;
    let currentPage = 1;
    let isLoadingRooms = false;
    let hasMoreRooms = true;
    let pendingRoom = null;
    let roomsCache = [];
    let allRoomsCache = [];
    let subscribedRooms = new Map();
    let messagePage = 1;
    let isLoadingMessages = false;
    let hasMoreMessages = true;
    let messagesCache = [];
    let processedMessageIds = new Set();
    let processedReadIds = new Set();
    let tempMessageMap = new Map();
    let isInitialRender = false;

    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    function waitForWebSocketConnection(timeout = 5000) {
        return new Promise((resolve, reject) => {
            if (stompClient && stompClient.connected) {
                return resolve();
            }
            let elapsed = 0;
            const interval = 100;
            const check = setInterval(() => {
                elapsed += interval;
                if (stompClient && stompClient.connected) {
                    clearInterval(check);
                    resolve();
                } else if (elapsed >= timeout) {
                    clearInterval(check);
                    reject(new Error('WebSocket connection timeout'));
                }
            }, interval);
        });
    }

    async function sendViewMessage(roomId, messageId) {
        if (!stompClient) {
            console.warn('Cannot send view message: stompClient is null', { roomId, messageId });
            return;
        }
        const viewPayload = {
            userId,
            roomId,
            messageId
        };
        try {
            await waitForWebSocketConnection();
            stompClient.send(`/pub/chat/rooms/${roomId}/view`, {}, JSON.stringify(viewPayload));
        } catch (error) {
            console.warn('Failed to send view message:', error, viewPayload);
        }
    }

    async function sendReadMessage(roomId, messageId) {
        if (!stompClient || !stompClient.connected) {
            console.warn('Cannot send read message: WebSocket not connected', { roomId, messageId });
            return;
        }
        if (!messageId || processedReadIds.has(messageId)) {
            return;
        }
        const readPayload = {
            roomId: roomId,
            userId: userId,
            messageId: messageId,
            type: 'ONE'
        };
        try {
            await waitForWebSocketConnection();
            stompClient.send(`/pub/chat/rooms/${roomId}/messages/${messageId}/read`, {}, JSON.stringify(readPayload));
            processedReadIds.add(messageId);
        } catch (error) {
            console.warn('Failed to send read message:', error, readPayload);
        }
    }

    const pages = {
        'login': document.getElementById('login-page'),
        'register': document.getElementById('register-page'),
        'rooms': document.getElementById('rooms-page'),
        'all-rooms': document.getElementById('all-rooms-page'),
        'chat': document.getElementById('chat-page'),
    };

    function unsubscribeRoom(roomId) {
        const subscriptions = subscribedRooms.get(roomId);
        if (subscriptions) {
            try {
                if (subscriptions.send) subscriptions.send.unsubscribe();
                if (subscriptions.read) subscriptions.read.unsubscribe();
                if (subscriptions.join) subscriptions.join.unsubscribe();
                if (subscriptions.leave) subscriptions.leave.unsubscribe();
            } catch (error) {
                console.error(`Error unsubscribing room ${roomId}:`, error);
            }
            subscribedRooms.delete(roomId);
        }
    }

    function navigate(page, pushState = true) {
        Object.values(pages).forEach(p => p.classList.add('hidden'));
        pages[page].classList.remove('hidden');
        if (pushState) {
            history.pushState({ page }, '', `#${page}`);
        }
        if (page === 'rooms') {
            currentRoom = null;
            currentRoomId = null;
            currentRoomMemberCount = 0;
            loadRooms('my');
        }
        if (page === 'all-rooms') {
            currentRoom = null;
            currentRoomId = null;
            currentRoomMemberCount = 0;
            currentPage = 1;
            hasMoreRooms = true;
            loadRooms('all');
        }
        if (page === 'chat' && currentRoom) {
            currentRoomId = currentRoom.id;
            document.getElementById('chat-room-title').textContent = currentRoom.name;
            currentRoomMemberCount = currentRoom.memberCount || 0;
            messagePage = 1;
            hasMoreMessages = true;
            messagesCache = [];
            processedMessageIds.clear();
            processedReadIds.clear();
            tempMessageMap.clear();
            const messagesDiv = document.getElementById('messages');
            isInitialRender = true;
            loadMessages(currentRoom.id).then(() => {
                const latestMessage = messagesCache[messagesCache.length - 1];
                const messageId = latestMessage && latestMessage.id && latestMessage.id !== '0' && latestMessage.id !== 0 ? latestMessage.id : null;
                sendViewMessage(currentRoom.id, messageId);
                if (stompClient && stompClient.connected && !subscribedRooms.has(currentRoom.id)) {
                    subscribeToRoom(currentRoom.id);
                    subscribeToReadMessages(currentRoom.id);
                    subscribeToJoinLeave(currentRoom.id);
                }
                setTimeout(() => {
                    isInitialRender = false;
                }, 100);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }).catch(error => {
                console.error('Error loading messages:', error);
                sendViewMessage(currentRoom.id, null);
                if (stompClient && stompClient.connected && !subscribedRooms.has(currentRoom.id)) {
                    subscribeToRoom(currentRoom.id);
                    subscribeToReadMessages(currentRoom.id);
                    subscribeToJoinLeave(currentRoom.id);
                }
                isInitialRender = false;
            });
        }
    }

    window.addEventListener('popstate', (e) => {
        const page = e.state?.page || 'login';
        navigate(page, false);
    });

    const api = axios.create({
        baseURL: 'http://localhost:8080',
        headers: { 'Content-Type': 'application/json' },
    });

    api.interceptors.request.use(config => {
        if (accessToken && config.url !== '/users/login' && config.url !== '/users/register' && config.url !== '/users/refresh') {
            config.headers.Authorization = `Bearer ${accessToken}`;
        }
        return config;
    });

    api.interceptors.response.use(
        response => response,
        async error => {
            const originalRequest = error.config;
            if (error.response?.status === 401 && !originalRequest._retry && originalRequest.url !== '/users/refresh') {
                originalRequest._retry = true;
                try {
                    const refreshResponse = await axios.post('http://localhost:8080/users/refresh', {}, {
                        headers: {
                            Authorization: `Bearer ${refreshToken}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    accessToken = refreshResponse.data.data.accessToken;
                    refreshToken = refreshResponse.data.data.refreshToken;
                    localStorage.setItem('accessToken', accessToken);
                    localStorage.setItem('refreshToken', refreshToken);
                    originalRequest.headers.Authorization = `Bearer ${accessToken}`;
                    return api(originalRequest);
                } catch (refreshError) {
                    if (refreshError.response?.status === 401) {
                        accessToken = null;
                        refreshToken = null;
                        userId = null;
                        nickname = null;
                        localStorage.removeItem('accessToken');
                        localStorage.removeItem('refreshToken');
                        localStorage.removeItem('userId');
                        localStorage.removeItem('nickname');
                        if (stompClient) {
                            stompClient.disconnect();
                            stompClient = null;
                        }
                        subscribedRooms.forEach((_, roomId) => unsubscribeRoom(roomId));
                        subscribedRooms.clear();
                        navigate('login');
                    }
                    return Promise.reject(refreshError);
                }
            }
            return Promise.reject(error);
        }
    );

    function connectWebSocket() {
        if (!accessToken) return;
        try {
            subscribedRooms.forEach((_, roomId) => unsubscribeRoom(roomId));
            subscribedRooms.clear();
            if (stompClient && stompClient.connected) {
                stompClient.disconnect();
            }
            const socket = new SockJS(`http://localhost:8081/ws?token=${accessToken}`);
            stompClient = Stomp.over(socket);
            stompClient.connect({}, () => {
                // Subscriptions handled by loadRooms, createRoom, or joinRoom
            }, (error) => {
                console.error('WebSocket connection error:', error);
                setTimeout(connectWebSocket, 5000);
            });
        } catch (error) {
            console.error('WebSocket connection failed:', error);
            setTimeout(connectWebSocket, 5000);
        }
    }

    function subscribeToRoom(roomId) {
        if (stompClient && stompClient.connected && !subscribedRooms.has(roomId)) {
            const subscription = stompClient.subscribe(`/sub/chat/rooms/${roomId}/messages/send`, (message) => {
                try {
                    const msg = JSON.parse(message.body);
                    const messageId = String(msg.messageId || msg.id || '');
                    if (!messageId) {
                        console.warn('Received message with missing or invalid messageId:', msg);
                        return;
                    }
                    if (processedMessageIds.has(messageId)) {
                        return;
                    }
                    processedMessageIds.add(messageId);
                    const normalizedMsg = {
                        ...msg,
                        id: messageId,
                        roomId: roomId,
                        isMine: msg.userId == userId,
                        content: msg.content || msg.message || 'No content',
                        nickname: msg.nickname || 'Unknown',
                        timestamp: msg.timestamp ? new Date(msg.timestamp).toISOString() : new Date().toISOString(),
                        unreadCount: msg.unreadCount !== undefined && msg.unreadCount > 0 ? msg.unreadCount : (msg.userId == userId ? currentRoomMemberCount : currentRoomMemberCount),
                        isTemporary: false
                    };
                    if (!msg.content && !msg.message) {
                        console.warn('Message missing content:', msg);
                    }
                    if (currentRoomId === roomId && !pages['chat'].classList.contains('hidden')) {
                        const recentDuplicate = messagesCache.find(cached =>
                            cached.content === normalizedMsg.content &&
                            cached.userId === normalizedMsg.userId &&
                            new Date().getTime() - new Date(cached.timestamp).getTime() < 1000
                        );
                        const temporaryMatch = messagesCache.find(cached =>
                            cached.isTemporary &&
                            cached.content === normalizedMsg.content &&
                            cached.userId === normalizedMsg.userId
                        );
                        if (temporaryMatch) {
                            const tempId = temporaryMatch.id;
                            temporaryMatch.id = normalizedMsg.id;
                            temporaryMatch.isTemporary = false;
                            temporaryMatch.timestamp = normalizedMsg.timestamp;
                            temporaryMatch.unreadCount = normalizedMsg.isMine && (normalizedMsg.unreadCount === undefined || normalizedMsg.unreadCount === 0) ? currentRoomMemberCount : normalizedMsg.unreadCount;
                            tempMessageMap.set(tempId, normalizedMsg.id);
                            const messageElement = document.querySelector(`[data-message-id="${tempId}"]`);
                            if (messageElement) {
                                messageElement.setAttribute('data-message-id', normalizedMsg.id);
                                updateUnreadSpan(messageElement, normalizedMsg.id, temporaryMatch.unreadCount);
                            }
                        } else if (!recentDuplicate && !messagesCache.some(cached => cached.id === normalizedMsg.id)) {
                            messagesCache.push(normalizedMsg);
                            appendMessage(normalizedMsg);
                        }
                        if (!processedReadIds.has(normalizedMsg.id)) {
                            sendReadMessage(roomId, normalizedMsg.id);
                        }
                    } else {
                        messagesCache.push(normalizedMsg);
                    }
                    updateRoomLastMessage(roomId, normalizedMsg);
                } catch (error) {
                    console.error('Error processing WebSocket message:', error, message.body);
                }
            });
            subscribedRooms.set(roomId, {
                send: subscription,
                read: subscribedRooms.get(roomId)?.read,
                join: subscribedRooms.get(roomId)?.join,
                leave: subscribedRooms.get(roomId)?.leave
            });
        }
    }

    function updateUnreadSpan(messageElement, messageId, unreadCount) {
        if (!messageElement) {
            console.warn('Cannot update unread span: messageElement is null', { messageId, unreadCount });
            return;
        }
        let infoBlock = messageElement.querySelector('.flex.flex-col');
        if (!infoBlock) {
            console.warn('infoBlock not found, creating new one', { messageId });
            const messageContent = messageElement.querySelector('.flex.items-end') || messageElement.querySelector('.flex.items-end.flex-row-reverse');
            if (messageContent) {
                infoBlock = document.createElement('div');
                infoBlock.className = `flex flex-col ${messageElement.classList.contains('justify-end') ? 'items-end ml-1' : 'items-start mr-1'} text-gray-500 text-xs leading-tight`;
                messageContent.appendChild(infoBlock);
            } else {
                console.error('Cannot create infoBlock: no suitable parent found', { messageId, elementHTML: messageElement.outerHTML });
                return;
            }
        }
        let unreadSpan = infoBlock.querySelector('.unread-count');
        if (unreadCount > 0) {
            if (!unreadSpan) {
                unreadSpan = document.createElement('span');
                unreadSpan.className = 'unread-count text-gray-500 text-xs';
                const timestampSpan = infoBlock.querySelector('.timestamp');
                if (timestampSpan) {
                    infoBlock.insertBefore(unreadSpan, timestampSpan);
                } else {
                    infoBlock.appendChild(unreadSpan);
                }
            }
            unreadSpan.textContent = unreadCount;
        } else if (unreadSpan) {
            unreadSpan.remove();
        }
    }

    function subscribeToReadMessages(roomId) {
        if (stompClient && stompClient.connected && !subscribedRooms.get(roomId)?.read) {
            const subscription = stompClient.subscribe(`/sub/chat/rooms/${roomId}/messages/read`, (message) => {
                try {
                    const readMsg = JSON.parse(message.body);
                    if (!readMsg.messageId) {
                        console.warn('Read message missing messageId:', readMsg);
                        return;
                    }
                    if (!readMsg.userId) {
                        console.warn('Read message missing userId:', readMsg);
                        return;
                    }
                    if (!readMsg.type || !['ALL', 'ONE'].includes(readMsg.type)) {
                        console.warn('Read message missing or invalid type:', readMsg);
                        return;
                    }

                    const roomIndex = roomsCache.findIndex(room => room.id === roomId);
                    if (roomIndex === -1) {
                        console.warn(`Room ${roomId} not found in roomsCache`);
                        return;
                    }

                    const decrement = 1;

                    if (currentRoomId === roomId) {
                        let messagesToUpdate = [];

                        if (readMsg.type === 'ALL') {
                            const targetMessage = messagesCache.find(msg => String(msg.id) === String(readMsg.messageId));
                            if (targetMessage) {
                                const targetUnreadCount = targetMessage.unreadCount || 0;
                                messagesToUpdate = messagesCache.filter(msg =>
                                    msg.roomId === roomId &&
                                    (msg.unreadCount || 0) === targetUnreadCount &&
                                    String(msg.id) <= String(readMsg.messageId)
                                );
                            } else {
                                console.warn('Target message not found for ALL:', readMsg.messageId);
                                return;
                            }
                        } else if (readMsg.type === 'ONE') {
                            const msg = messagesCache.find(msg => {
                                const tempId = tempMessageMap.get(msg.id);
                                return String(msg.id) === String(readMsg.messageId) || (tempId && String(tempId) === String(readMsg.messageId));
                            });
                            if (msg) {
                                messagesToUpdate.push(msg);
                            } else {
                                console.warn('Target message not found for ONE:', readMsg.messageId);
                                return;
                            }
                        }

                        messagesCache = messagesCache.map(msg => {
                            const isTarget = messagesToUpdate.some(target => target.id === msg.id);
                            if (isTarget && msg.roomId === roomId && (msg.unreadCount || 0) > 0) {
                                if (readMsg.type === 'ALL' || (readMsg.type === 'ONE' && (!isInitialRender || msg.isMine))) {
                                    return { ...msg, unreadCount: Math.max(0, (msg.unreadCount || 0) - 1) };
                                }
                            }
                            return msg;
                        });

                        // 갱신된 messagesCache에서 최신 메시지 찾기
                        messagesToUpdate = messagesToUpdate.map(original =>
                            messagesCache.find(m => m.id === original.id) || original
                        );

                        // 렌더링
                        if (!pages['chat'].classList.contains('hidden')) {
                            const messagesDiv = document.getElementById('messages');
                            messagesToUpdate.forEach(msg => {
                                const messageElement = messagesDiv.querySelector(`[data-message-id="${msg.id}"]`);
                                if (messageElement) {
                                    messageElement.remove();
                                }
                                appendMessage(msg, false);
                            });

                            const wasAtBottom = messagesDiv.scrollTop + messagesDiv.clientHeight >= messagesDiv.scrollHeight - 20;
                            if (wasAtBottom) {
                                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                            }
                        }
                    } else {
                        const targetRoom = roomsCache[roomIndex];
                        if (targetRoom && targetRoom.unreadCount > 0 && readMsg.userId === userId) {
                            roomsCache[roomIndex] = {
                                ...targetRoom,
                                unreadCount: Math.max(0, targetRoom.unreadCount - decrement)
                            };
                            renderRooms('my');
                        }
                    }
                } catch (error) {
                    console.error('Error processing read message:', error, message.body);
                }
            });
            subscribedRooms.set(roomId, {
                send: subscribedRooms.get(roomId)?.send,
                read: subscription,
                join: subscribedRooms.get(roomId)?.join,
                leave: subscribedRooms.get(roomId)?.leave
            });
        }
    }

    function subscribeToJoinLeave(roomId) {
        if (stompClient && stompClient.connected && !subscribedRooms.get(roomId)?.join) {
            const joinSubscription = stompClient.subscribe(`/sub/chat/rooms/${roomId}/join`, (message) => {
                try {
                    const joinMsg = JSON.parse(message.body);
                    if (!joinMsg.userId) {
                        console.warn('Join message missing userId:', joinMsg);
                        return;
                    }
                    if (currentRoomId === roomId) {
                        currentRoomMemberCount = Math.max(1, currentRoomMemberCount + 1);
                        const roomIndex = roomsCache.findIndex(room => room.id === roomId);
                        if (roomIndex !== -1) {
                            roomsCache[roomIndex].memberCount = currentRoomMemberCount;
                            renderRooms('my');
                        }
                    }
                } catch (error) {
                    console.error('Error processing join message:', error, message.body);
                }
            });
            const leaveSubscription = stompClient.subscribe(`/sub/chat/rooms/${roomId}/leave`, (message) => {
                try {
                    const leaveMsg = JSON.parse(message.body);
                    if (!leaveMsg.userId) {
                        console.warn('Leave message missing userId:', leaveMsg);
                        return;
                    }
                    if (currentRoomId === roomId) {
                        currentRoomMemberCount = Math.max(1, currentRoomMemberCount - 1);
                        const roomIndex = roomsCache.findIndex(room => room.id === roomId);
                        if (roomIndex !== -1) {
                            roomsCache[roomIndex].memberCount = currentRoomMemberCount;
                            renderRooms('my');
                        }
                    }
                } catch (error) {
                    console.error('Error processing leave message:', error, message.body);
                }
            });
            subscribedRooms.set(roomId, {
                send: subscribedRooms.get(roomId)?.send,
                read: subscribedRooms.get(roomId)?.read,
                join: joinSubscription,
                leave: leaveSubscription
            });
        }
    }

    function updateRoomLastMessage(roomId, msg) {
        const roomIndex = roomsCache.findIndex(room => room.id === roomId);
        if (roomIndex !== -1) {
            roomsCache[roomIndex].lastMessage = msg.content || msg.message;
            roomsCache[roomIndex].lastMessageTime = msg.timestamp;
            if (currentRoomId !== roomId && msg.userId !== userId) {
                roomsCache[roomIndex].unreadCount = (roomsCache[roomIndex].unreadCount || 0) + 1;
            }
            roomsCache.sort((a, b) => new Date(b.lastMessageTime || 0) - new Date(a.lastMessageTime || 0));
            renderRooms('my');
        }
        const allRoomIndex = allRoomsCache.findIndex(room => room.id === roomId);
        if (allRoomIndex !== -1) {
            allRoomsCache[allRoomIndex].lastMessage = msg.content || msg.message;
            allRoomsCache[allRoomIndex].lastMessageTime = msg.timestamp;
            allRoomsCache.sort((a, b) => new Date(b.lastMessageTime || 0) - new Date(a.lastMessageTime || 0));
            renderRooms('all');
        }
    }

    function renderRooms(type) {
        const roomsList = type === 'my' ? document.getElementById('rooms-list') : document.getElementById('all-rooms-list');
        const cache = type === 'my' ? roomsCache : allRoomsCache;
        roomsList.innerHTML = '';
        cache.forEach(room => {
            const div = document.createElement('div');
            div.className = 'p-4 bg-gray-100 rounded-lg hover:bg-gray-200 cursor-pointer';
            div.innerHTML = `
                <div class="flex items-center space-x-3">
                    <img src="${room.image || 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22white%22%3E%3Ccircle cx=%2212%22 cy=%2212%22 r=%2212%22/%3E%3C/svg%3E'}" class="w-10 h-10 rounded-full object-cover">
                    <div class="flex-1">
                        <div class="flex justify-between">
                            <h2 class="font-bold">${room.name || 'Unnamed Room'} <span class="text-gray-500 text-sm">(${room.memberCount || 0})</span></h2>
                            <span class="text-sm text-gray-500">${room.lastMessageTime ? new Date(room.lastMessageTime).toLocaleTimeString() : ''}</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <p class="text-gray-600 truncate flex-1">${room.lastMessage || 'No messages'}</p>
                            ${room.unreadCount > 0 ? `<div class="bg-red-500 text-white text-xs px-2 py-1 rounded-full">${room.unreadCount}</div>` : ''}
                        </div>
                    </div>
                </div>
            `;
            div.addEventListener('click', () => {
                currentRoom = room;
                if (type === 'all' && !room.isJoined) {
                    pendingRoom = room;
                    document.getElementById('join-room-modal').classList.remove('hidden');
                } else {
                    room.unreadCount = 0;
                    renderRooms(type);
                    navigate('chat');
                }
            });
            roomsList.appendChild(div);
        });
    }

    async function register(email, nickname, password) {
        try {
            const res = await api.post('/users/register', { email, nickname, password });
            accessToken = res.data.data.accessToken;
            refreshToken = res.data.data.refreshToken;
            localStorage.setItem('accessToken', accessToken);
            localStorage.setItem('refreshToken', refreshToken);
            alert('회원가입 성공! 로그인해주세요.');
            navigate('login');
        } catch (error) {
            alert('회원가입 실패: ' + error.response?.data?.message || '오류 발생');
        }
    }

    async function login(email, password) {
        try {
            const res = await api.post('/users/login', { email, password });
            accessToken = res.data.data.accessToken;
            refreshToken = res.data.data.refreshToken;
            localStorage.setItem('accessToken', accessToken);
            localStorage.setItem('refreshToken', refreshToken);
            await fetchCurrentUser();
            connectWebSocket();
            navigate('rooms');
        } catch (error) {
            alert('로그인 실패: ' + error.response?.data?.message || '오류 발생');
        }
    }

    async function fetchCurrentUser() {
        try {
            const res = await api.get('/users/me');
            userId = res.data.data.id;
            nickname = res.data.data.nickname;
            localStorage.setItem('userId', userId);
            localStorage.setItem('nickname', nickname);
        } catch (error) {
            console.error('Failed to fetch user:', error);
            throw error;
        }
    }

    async function createRoom(name) {
        try {
            const res = await api.post('/chat/rooms', { name });
            const newRoom = res.data.data;
            currentRoom = newRoom;
            currentRoomId = newRoom.id;
            currentRoomMemberCount = newRoom.memberCount || 1;
            if (stompClient && stompClient.connected && !subscribedRooms.has(newRoom.id)) {
                subscribeToRoom(newRoom.id);
                subscribeToReadMessages(newRoom.id);
                subscribeToJoinLeave(newRoom.id);
            }
            roomsCache.unshift(newRoom);
            renderRooms('my');
            alert('채팅방이 생성되었습니다.');
            document.getElementById('create-room-modal').classList.add('hidden');
            document.getElementById('room-name-input').value = '';
            navigate('chat');
        } catch (error) {
            alert('채팅방 생성 실패: ' + error.response?.data?.message || '오류 발생');
        }
    }

    async function joinRoom(roomId) {
        try {
            await api.post(`/chat/rooms/${roomId}/join`);
            if (stompClient && stompClient.connected && !subscribedRooms.has(roomId)) {
                subscribeToRoom(roomId);
                subscribeToReadMessages(roomId);
                subscribeToJoinLeave(roomId);
            }
            const room = allRoomsCache.find(r => r.id === roomId);
            if (room) {
                room.isJoined = true;
                room.memberCount = room.memberCount ? room.memberCount + 1 : 1;
                roomsCache.unshift(room);
                currentRoom = room;
                currentRoomId = roomId;
                renderRooms('my');
            }
            navigate('chat');
        } catch (error) {
            alert('채팅방 참여 실패: ' + error.response?.data?.message || '오류 발생');
        }
    }

    async function loadRooms(type, append = false) {
        if (isLoadingRooms) return;
        isLoadingRooms = true;
        try {
            const endpoint = type === 'all' ? `/chat/rooms?page=${currentPage}&size=10` : '/chat/rooms/me';
            const res = await api.get(endpoint);
            const roomsList = type === 'my' ? document.getElementById('rooms-list') : document.getElementById('all-rooms-list');
            const cache = type === 'my' ? roomsCache : allRoomsCache;
            if (!append) {
                cache.length = 0;
                roomsList.innerHTML = '';
            }
            const rooms = (res.data.data || []).map(room => ({
                ...room,
                lastMessageTime: room.lastSentAt ? new Date(room.lastSentAt).toISOString() : null,
                unreadCount: room.unreadCount || 0,
                memberCount: room.memberCount || 1
            }));
            if (type === 'all' && rooms.length < 10) {
                hasMoreRooms = false;
            }
            cache.push(...rooms);
            cache.sort((a, b) => new Date(b.lastMessageTime || 0) - new Date(a.lastMessageTime || 0));
            renderRooms(type);
            if (type === 'my' && stompClient && stompClient.connected) {
                rooms.forEach(room => {
                    if (!subscribedRooms.has(room.id)) {
                        subscribeToRoom(room.id);
                        subscribeToReadMessages(room.id);
                        subscribeToJoinLeave(room.id);
                    }
                });
            }
            if (type === 'all' && append) {
                currentPage++;
            }
        } catch (error) {
            console.error('Failed to load rooms:', error);
            alert('채팅방 목록을 불러오지 못했습니다.');
        } finally {
            isLoadingRooms = false;
        }
    }

    async function loadMessages(roomId, append = false) {
        if (isLoadingMessages || !hasMoreMessages) return;
        isLoadingMessages = true;
        try {
            const res = await api.get(`/chat/rooms/${roomId}/messages?page=${messagePage}&size=30`);
            const messagesDiv = document.getElementById('messages');
            const scrollHeightBefore = messagesDiv.scrollHeight;
            const scrollTopBefore = messagesDiv.scrollTop;
            const wasAtBottom = messagesDiv.scrollTop + messagesDiv.clientHeight >= messagesDiv.scrollHeight - 50;

            if (!append) {
                messagesCache = [];
                processedMessageIds.clear();
                messagesDiv.innerHTML = '';
            }

            const messages = Array.isArray(res.data.data) ? res.data.data.map(msg => {
                const id = String(msg.messageId || msg.id || '');
                if (!id) {
                    console.warn('Message missing id:', msg);
                }
                return {
                    ...msg,
                    id,
                    roomId,
                    isMine: msg.userId == userId,
                    content: msg.content || 'No content',
                    nickname: msg.nickname || 'Unknown',
                    timestamp: msg.timestamp || new Date().toISOString(),
                    unreadCount: msg.unreadCount !== undefined ? msg.unreadCount : currentRoomMemberCount,
                    isTemporary: false
                };
            }).filter(msg => msg.id) : [];
            if (messages.length < 30) {
                hasMoreMessages = false;
            }

            messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (append) {
                messagesCache.unshift(...messages);
            } else {
                messagesCache.push(...messages);
            }

            renderMessages(messagesDiv, wasAtBottom, scrollHeightBefore, append, scrollTopBefore, messages);

            if (!append) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            } else {
                messagesDiv.scrollTop = messagesDiv.scrollHeight - scrollHeightBefore + scrollTopBefore;
            }

            messagePage++;
        } catch (error) {
            console.error('Failed to load messages:', error);
            alert('메시지를 불러오지 못했습니다.');
            throw error;
        } finally {
            isLoadingMessages = false;
        }
    }

    function renderMessages(messagesDiv, wasAtBottom, scrollHeightBefore, append, scrollTopBefore, messages = []) {
        if (!append) {
            messagesDiv.innerHTML = '';
        }
        if (messagesCache.length === 0) {
            messagesDiv.innerHTML = '<p class="text-gray-500 text-center">No messages</p>';
            return;
        }
        const messagesToRender = append ? messages : messagesCache;
        messagesToRender.forEach(msg => {
            appendMessage(msg, false, append);
        });
    }

    function appendMessage(msg, scrollToBottom = true, prepend = false) {
        const messagesDiv = document.getElementById('messages');
        if (!msg.id) {
            console.warn('Skipping message with missing id:', msg);
            return;
        }

        const existingElement = messagesDiv.querySelector(`[data-message-id="${msg.id}"]`);
        if (existingElement) {
            existingElement.remove();
        }

        const div = document.createElement('div');
        div.setAttribute('data-message-id', msg.id);
        const isMine = msg.isMine || false;
        const nickname = msg.nickname || 'Unknown';
        const content = msg.content || 'No content';
        const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : '';
        const unread = msg.unreadCount > 0 ? `<span class="unread-count text-gray-500 text-xs">${msg.unreadCount}</span>` : '';

        const infoBlock = `
            <div class="flex flex-col ${isMine ? 'items-end ml-1' : 'items-start mr-1'} text-gray-500 text-xs leading-tight">
                ${unread}
                ${timestamp ? `<span class="timestamp ${isMine ? 'mt-1' : ''} text-gray-500 text-xs">${timestamp}</span>` : ''}
            </div>
        `;

        div.className = `flex items-start mb-2 ${isMine ? 'justify-end' : 'justify-start'}`;
        div.innerHTML = `
            <div class="flex flex-col max-w-xs">
                <p class="text-xs text-gray-600 mb-1 ${isMine ? 'text-right' : 'text-left'}">${nickname}</p>
                <div class="flex items-end ${isMine ? 'flex-row-reverse' : 'flex-row'}">
                    <div class="p-3 rounded-lg ${isMine ? 'bg-blue-500 text-white ml-1' : 'bg-gray-200 text-gray-800 mr-1'}">
                        <p class="text-sm">${content}</p>
                    </div>
                    ${infoBlock}
                </div>
            </div>
        `;

        try {
            const wasAtBottom = messagesDiv.scrollTop + messagesDiv.clientHeight >= messagesDiv.scrollHeight - 50;
            if (prepend) {
                messagesDiv.insertBefore(div, messagesDiv.firstChild);
            } else {
                messagesDiv.appendChild(div);
            }
            if (scrollToBottom && (wasAtBottom || isMine) && !prepend) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        } catch (error) {
            console.error('Error appending message to DOM:', error, msg, div.outerHTML);
        }
    }

    function sendMessage() {
        const content = document.getElementById('message-input').value;
        if (!content.trim()) {
            alert('메시지를 입력하세요.');
            return;
        }
        if (!stompClient || !stompClient.connected) {
            alert('WebSocket 연결이 없습니다. 다시 시도해주세요.');
            return;
        }
        if (!currentRoom) {
            alert('채팅방이 선택되지 않았습니다.');
            return;
        }
        try {
            const tempId = `temp-${Date.now()}`;
            const tempMessage = {
                id: tempId,
                roomId: currentRoom.id,
                userId: userId,
                nickname: nickname,
                content: content,
                isMine: true,
                timestamp: new Date().toISOString(),
                unreadCount: currentRoomMemberCount,
                isTemporary: true
            };
            messagesCache.push(tempMessage);
            appendMessage(tempMessage);
            stompClient.send(`/pub/chat/rooms/${currentRoom.id}/messages/send`, {}, JSON.stringify({
                roomId: currentRoom.id,
                userId: userId,
                nickname: nickname,
                content: content
            }));
            document.getElementById('message-input').value = '';
        } catch (error) {
            console.error('Error sending message:', error);
            alert('메시지 전송에 실패했습니다.');
        }
    }

    function addEventListeners() {
        document.getElementById('login-btn').addEventListener('click', () => {
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            if (!email || !password) {
                alert('이메일과 비밀번호를 입력하세요.');
                return;
            }
            login(email, password);
        });

        document.getElementById('to-register-btn').addEventListener('click', () => navigate('register'));

        document.getElementById('register-btn').addEventListener('click', () => {
            const email = document.getElementById('register-email').value;
            const nickname = document.getElementById('register-nickname').value;
            const password = document.getElementById('register-password').value;
            if (!email || !nickname || !password) {
                alert('이메일, 닉네임, 비밀번호를 입력하세요.');
                return;
            }
            register(email, nickname, password);
        });

        document.getElementById('back-to-login-btn').addEventListener('click', () => navigate('login'));

        document.getElementById('logout-btn').addEventListener('click', () => {
            accessToken = null;
            refreshToken = null;
            userId = null;
            nickname = null;
            localStorage.removeItem('accessToken');
            localStorage.removeItem('refreshToken');
            localStorage.removeItem('userId');
            localStorage.removeItem('nickname');
            if (stompClient) {
                stompClient.disconnect();
                stompClient = null;
            }
            subscribedRooms.forEach((_, roomId) => unsubscribeRoom(roomId));
            subscribedRooms.clear();
            navigate('login');
        });

        document.getElementById('search-rooms-btn').addEventListener('click', () => {
            navigate('all-rooms');
        });

        document.getElementById('back-to-my-rooms-btn').addEventListener('click', () => {
            navigate('rooms');
        });

        document.getElementById('back-to-rooms-btn').addEventListener('click', () => {
            currentRoom = null;
            currentRoomId = null;
            currentRoomMemberCount = 0;
            processedMessageIds.clear();
            processedReadIds.clear();
            tempMessageMap.clear();
            navigate('rooms');
        });

        document.getElementById('send-message-btn').addEventListener('click', sendMessage);

        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        document.getElementById('create-room-btn').addEventListener('click', () => {
            document.getElementById('create-room-modal').classList.remove('hidden');
        });

        document.getElementById('create-room-confirm-btn').addEventListener('click', () => {
            const roomName = document.getElementById('room-name-input').value;
            if (!roomName.trim()) {
                alert('채팅방 이름을 입력하세요.');
                return;
            }
            createRoom(roomName);
        });

        document.getElementById('create-room-cancel-btn').addEventListener('click', () => {
            document.getElementById('create-room-modal').classList.add('hidden');
            document.getElementById('room-name-input').value = '';
        });

        document.getElementById('join-room-confirm-btn').addEventListener('click', () => {
            if (pendingRoom) {
                joinRoom(pendingRoom.id);
            }
            document.getElementById('join-room-modal').classList.add('hidden');
            pendingRoom = null;
        });

        document.getElementById('join-room-cancel-btn').addEventListener('click', () => {
            document.getElementById('join-room-modal').classList.add('hidden');
            pendingRoom = null;
            currentRoom = null;
            currentRoomId = null;
        });

        const allRoomsList = document.getElementById('all-rooms-list');
        const debouncedLoadAllRooms = debounce(() => {
            if (allRoomsList.scrollTop + allRoomsList.clientHeight >= allRoomsList.scrollHeight - 20 && !isLoadingRooms && hasMoreRooms) {
                loadRooms('all', true);
            }
        }, 300);
        allRoomsList.addEventListener('scroll', debouncedLoadAllRooms);

        const messagesDiv = document.getElementById('messages');
        const debouncedLoadMessages = debounce(() => {
            if (messagesDiv.scrollTop <= 20 && !isLoadingMessages && hasMoreMessages && currentRoom) {
                loadMessages(currentRoom.id, true);
            }
        }, 300);
        messagesDiv.addEventListener('scroll', debouncedLoadMessages);
    }

    async function initialize() {
        try {
            if (accessToken && userId && nickname) {
                await fetchCurrentUser();
                connectWebSocket();
                navigate('rooms');
            } else {
                navigate('login');
            }
        } catch (error) {
            console.error('Initialization error:', error);
            localStorage.clear();
            navigate('login');
        }
        addEventListeners();
    }

    initialize();
</script>
</body>
</html>
